pub mod events;

use once_cell::sync::Lazy;
use serde::Deserialize;
use std::{collections::HashSet, env, fs};

/// Configuration for global streams and per-symbol stream suffixes.
#[derive(Clone, Deserialize)]
pub struct StreamConfig {
    pub global: Vec<String>,
    #[serde(rename = "per_symbol")]
    pub per_symbol: Vec<String>,
}

/// Loads the stream configuration from a JSON file specified by the
/// `STREAMS_CONFIG` environment variable. If the variable is unset or the file
/// fails to load, a built-in default configuration is used.
static STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    if let Ok(path) = env::var("STREAMS_CONFIG") {
        if let Ok(content) = fs::read_to_string(path) {
            if let Ok(cfg) = serde_json::from_str(&content) {
                return cfg;
            }
        }
    }
    serde_json::from_str(include_str!("../streams.json"))
        .expect("invalid default stream configuration")
});

// Exchange specific configurations
static SPOT_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    serde_json::from_str(include_str!("../streams_spot.json"))
        .expect("invalid spot stream configuration")
});

static FUTURES_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    serde_json::from_str(include_str!("../streams_futures.json"))
        .expect("invalid futures stream configuration")
});

static OPTIONS_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    serde_json::from_str(include_str!("../streams_options.json"))
        .expect("invalid options stream configuration")
});

/// Returns the default stream configuration.
pub fn default_stream_config() -> &'static StreamConfig {
    &STREAM_CONFIG
}

/// Returns the stream configuration for the given exchange name.
pub fn stream_config_for_exchange(name: &str) -> &'static StreamConfig {
    match name {
        "Binance.US Spot" | "Binance Global Spot" => &SPOT_STREAM_CONFIG,
        "Binance Futures" | "Binance Delivery" => &FUTURES_STREAM_CONFIG,
        "Binance Options" => &OPTIONS_STREAM_CONFIG,
        _ => default_stream_config(),
    }
}

/// Builds a list of Binance WebSocket stream names split into chunks using the
/// global stream configuration.
///
/// Global streams are combined with per-symbol streams generated by pairing
/// each symbol with a set of suffixes. Symbols are lowercased before being
/// combined. The complete list is then divided into chunks containing at most
/// `chunk_size` stream names.
pub fn chunk_streams(symbols: &[&str], chunk_size: usize) -> Vec<Vec<String>> {
    chunk_streams_with_config(symbols, chunk_size, default_stream_config())
}

/// Builds stream name chunks using a provided configuration.
pub fn chunk_streams_with_config(
    symbols: &[&str],
    chunk_size: usize,
    config: &StreamConfig,
) -> Vec<Vec<String>> {
    if chunk_size == 0 {
        return Vec::new();
    }

    let mut stream_set: HashSet<String> =
        HashSet::with_capacity(config.global.len() + symbols.len() * config.per_symbol.len());
    stream_set.extend(config.global.iter().cloned());

    for &sym in symbols {
        let sym_lower = sym.to_lowercase();
        for suffix in &config.per_symbol {
            stream_set.insert(format!("{}@{}", sym_lower, suffix));
        }
    }

    let mut streams: Vec<String> = stream_set.into_iter().collect();
    streams.sort();
    let capacity = (streams.len() + chunk_size - 1) / chunk_size;
    let mut result = Vec::with_capacity(capacity);
    for chunk in streams.chunks(chunk_size) {
        result.push(chunk.to_vec());
    }
    result
}
