pub mod events;

use metrics::counter;
use once_cell::sync::Lazy;
use serde::Deserialize;
use std::{collections::HashSet, env, fs, time::Duration};
use tracing::{debug, info, warn};

use crate::events::{Event, StreamMessage};

/// Configuration for global streams and per-symbol stream suffixes.
#[derive(Clone, Deserialize)]
pub struct StreamConfig {
    pub global: Vec<String>,
    #[serde(rename = "per_symbol")]
    pub per_symbol: Vec<String>,
}

/// Loads the stream configuration from a JSON file specified by the
/// `STREAMS_CONFIG` environment variable. If the variable is unset or the file
/// fails to load, a built-in default configuration is used.
static STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    if let Ok(path) = env::var("STREAMS_CONFIG") {
        if let Ok(content) = fs::read_to_string(path) {
            if let Ok(cfg) = serde_json::from_str(&content) {
                return cfg;
            }
        }
    }
    serde_json::from_str(include_str!("../streams.json"))
        .expect("invalid default stream configuration")
});

// Exchange specific configurations
static SPOT_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    serde_json::from_str(include_str!("../streams_spot.json"))
        .expect("invalid spot stream configuration")
});

static FUTURES_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    serde_json::from_str(include_str!("../streams_futures.json"))
        .expect("invalid futures stream configuration")
});

static OPTIONS_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    serde_json::from_str(include_str!("../streams_options.json"))
        .expect("invalid options stream configuration")
});

/// Returns the default stream configuration.
pub fn default_stream_config() -> &'static StreamConfig {
    &STREAM_CONFIG
}

/// Returns the stream configuration for the given exchange name.
pub fn stream_config_for_exchange(name: &str) -> &'static StreamConfig {
    match name {
        "Binance.US Spot" | "Binance Global Spot" => &SPOT_STREAM_CONFIG,
        "Binance Futures" | "Binance Delivery" => &FUTURES_STREAM_CONFIG,
        "Binance Options" => &OPTIONS_STREAM_CONFIG,
        _ => default_stream_config(),
    }
}

/// Builds a list of Binance WebSocket stream names split into chunks using the
/// global stream configuration.
///
/// Global streams are combined with per-symbol streams generated by pairing
/// each symbol with a set of suffixes. Symbols are lowercased before being
/// combined. The complete list is then divided into chunks containing at most
/// `chunk_size` stream names.
pub fn chunk_streams(symbols: &[&str], chunk_size: usize) -> Vec<Vec<String>> {
    chunk_streams_with_config(symbols, chunk_size, default_stream_config())
}

/// Builds stream name chunks using a provided configuration.
pub fn chunk_streams_with_config(
    symbols: &[&str],
    chunk_size: usize,
    config: &StreamConfig,
) -> Vec<Vec<String>> {
    if chunk_size == 0 {
        return Vec::new();
    }

    let mut stream_set: HashSet<String> =
        HashSet::with_capacity(config.global.len() + symbols.len() * config.per_symbol.len());
    stream_set.extend(config.global.iter().cloned());

    for &sym in symbols {
        let sym_lower = sym.to_lowercase();
        for suffix in &config.per_symbol {
            stream_set.insert(format!("{}@{}", sym_lower, suffix));
        }
    }

    let mut streams: Vec<String> = stream_set.into_iter().collect();
    streams.sort();
    let capacity = (streams.len() + chunk_size - 1) / chunk_size;
    let mut result = Vec::with_capacity(capacity);
    for chunk in streams.chunks(chunk_size) {
        result.push(chunk.to_vec());
    }
    result
}

/// Calculates the next backoff duration for reconnection attempts.
///
/// If a run completed successfully and lasted at least `min_stable`, the
/// backoff is reset to one second. Otherwise it doubles, bounded by
/// `max_backoff`.
pub fn next_backoff(
    previous: Duration,
    run_duration: Duration,
    was_successful: bool,
    max_backoff: Duration,
    min_stable: Duration,
) -> Duration {
    if was_successful && run_duration >= min_stable {
        Duration::from_secs(1)
    } else {
        std::cmp::min(previous * 2, max_backoff)
    }
}

/// Logs stream events, warning on unknown types and optionally incrementing a
/// metric. The raw payload is included for easier troubleshooting.
pub fn handle_stream_event(event: &StreamMessage<Event>, raw: &str) {
    match &event.data {
        Event::Trade(data) => info!(event = "trade", symbol = %data.symbol),
        Event::AggTrade(data) => info!(event = "aggTrade", symbol = %data.symbol),
        Event::DepthUpdate(data) => info!(event = "depthUpdate", symbol = %data.symbol),
        Event::Kline(data) => info!(event = "kline", symbol = %data.symbol),
        Event::MiniTicker(data) => info!(event = "miniTicker", symbol = %data.symbol),
        Event::Ticker(data) => info!(event = "ticker", symbol = %data.symbol),
        Event::BookTicker(data) => info!(event = "bookTicker", symbol = %data.symbol),
        Event::IndexPrice(data) => info!(event = "indexPriceUpdate", symbol = %data.symbol),
        Event::MarkPrice(data) => info!(event = "markPriceUpdate", symbol = %data.symbol),
        Event::MarkPriceKline(data) => info!(event = "markPriceKline", symbol = %data.symbol),
        Event::IndexPriceKline(data) => info!(event = "indexPriceKline", symbol = %data.symbol),
        Event::ContinuousKline(data) => {
            info!(event = "continuous_kline", pair = %data.pair, contract_type = %data.contract_type)
        }
        Event::ForceOrder(data) => info!(event = "forceOrder", symbol = %data.order.symbol),
        Event::Unknown => {
            warn!(
                event = "unknown",
                stream = %event.stream,
                payload = %raw,
                "unknown event"
            );
            counter!("unknown_events").increment(1);
        }
    }
    debug!(?event);
}
