pub mod events;

use metrics::counter;
use once_cell::sync::Lazy;
use serde::Deserialize;
use std::{collections::{HashMap, HashSet}, env, fs, time::Duration};
#[cfg(feature = "debug-logs")]
use tracing::debug;
use tracing::{info, warn};

use crate::events::{Event, StreamMessage};

/// Configuration for global streams and per-symbol stream suffixes.
#[derive(Clone, Deserialize)]
pub struct StreamConfig {
    pub global: Vec<String>,
    #[serde(rename = "per_symbol")]
    pub per_symbol: Vec<String>,
}

/// Loads the stream configuration from a JSON file specified by the
/// `STREAMS_CONFIG` environment variable. If the variable is unset or the file
/// fails to load, a built-in default configuration is used.
static STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    if let Ok(path) = env::var("STREAMS_CONFIG") {
        if let Ok(content) = fs::read_to_string(path) {
            if let Ok(cfg) = serde_json::from_str(&content) {
                return cfg;
            }
        }
    }
    serde_json::from_str(include_str!("../streams.json"))
        .expect("invalid default stream configuration")
});

// Exchange specific configurations
static SPOT_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    serde_json::from_str(include_str!("../streams_spot.json"))
        .expect("invalid spot stream configuration")
});

static FUTURES_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    serde_json::from_str(include_str!("../streams_futures.json"))
        .expect("invalid futures stream configuration")
});

static OPTIONS_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    serde_json::from_str(include_str!("../streams_options.json"))
        .expect("invalid options stream configuration")
});

/// Returns the default stream configuration.
pub fn default_stream_config() -> &'static StreamConfig {
    &STREAM_CONFIG
}

/// Returns the stream configuration for the given exchange name.
pub fn stream_config_for_exchange(name: &str) -> &'static StreamConfig {
    match name {
        "Binance.US Spot" | "Binance Global Spot" => &SPOT_STREAM_CONFIG,
        "Binance Futures" | "Binance Delivery" => &FUTURES_STREAM_CONFIG,
        "Binance Options" => &OPTIONS_STREAM_CONFIG,
        _ => default_stream_config(),
    }
}

/// Builds a list of Binance WebSocket stream names split into chunks using the
/// global stream configuration.
///
/// Global streams are combined with per-symbol streams generated by pairing
/// each symbol with a set of suffixes. Symbols are lowercased before being
/// combined. The complete list is then divided into chunks containing at most
/// `chunk_size` stream names.
pub fn chunk_streams(symbols: &[&str], chunk_size: usize) -> Vec<Vec<String>> {
    chunk_streams_with_config(symbols, chunk_size, default_stream_config())
}

/// Builds stream name chunks using a provided configuration.
pub fn chunk_streams_with_config(
    symbols: &[&str],
    chunk_size: usize,
    config: &StreamConfig,
) -> Vec<Vec<String>> {
    if chunk_size == 0 {
        return Vec::new();
    }

    let mut stream_set: HashSet<String> =
        HashSet::with_capacity(config.global.len() + symbols.len() * config.per_symbol.len());
    stream_set.extend(config.global.iter().cloned());

    for &sym in symbols {
        let sym_lower = sym.to_lowercase();
        for suffix in &config.per_symbol {
            stream_set.insert(format!("{}@{}", sym_lower, suffix));
        }
    }

    let mut streams: Vec<String> = stream_set.into_iter().collect();
    streams.sort();
    let capacity = (streams.len() + chunk_size - 1) / chunk_size;
    let mut result = Vec::with_capacity(capacity);
    for chunk in streams.chunks(chunk_size) {
        result.push(chunk.to_vec());
    }
    result
}

/// Calculates the next backoff duration for reconnection attempts.
///
/// If a run completed successfully and lasted at least `min_stable`, the
/// backoff is reset to one second. Otherwise it doubles, bounded by
/// `max_backoff`.
pub fn next_backoff(
    previous: Duration,
    run_duration: Duration,
    was_successful: bool,
    max_backoff: Duration,
    min_stable: Duration,
) -> Duration {
    if was_successful && run_duration >= min_stable {
        Duration::from_secs(1)
    } else {
        std::cmp::min(previous * 2, max_backoff)
    }
}

/// Logs a warning for unknown events. The raw payload is included for easier troubleshooting.
pub fn handle_stream_event(event: &StreamMessage<Event>, raw: &str) {
    if matches!(event.data, Event::Unknown) {
        warn!(
            event = "unknown",
            stream = %event.stream,
            payload = %raw,
            "unknown event",
        );
        counter!("unknown_events").increment(1);
    }
}

// Order book handling -------------------------------------------------------

use events::DepthUpdateEvent;

/// Snapshot of the order book returned by the REST `depth` endpoint.
#[derive(Debug, Deserialize)]
pub struct DepthSnapshot {
    #[serde(rename = "lastUpdateId")]
    pub last_update_id: u64,
    pub bids: Vec<[String; 2]>,
    pub asks: Vec<[String; 2]>,
}

/// In-memory representation of an order book for a single symbol.
#[derive(Debug, Clone, Default)]
pub struct OrderBook {
    pub bids: HashMap<String, String>,
    pub asks: HashMap<String, String>,
    pub last_update_id: u64,
}

impl From<DepthSnapshot> for OrderBook {
    fn from(snapshot: DepthSnapshot) -> Self {
        Self {
            bids: snapshot
                .bids
                .into_iter()
                .map(|[p, q]| (p, q))
                .collect(),
            asks: snapshot
                .asks
                .into_iter()
                .map(|[p, q]| (p, q))
                .collect(),
            last_update_id: snapshot.last_update_id,
        }
    }
}

/// Applies a websocket depth update diff to an existing order book snapshot.
pub fn apply_depth_update(book: &mut OrderBook, update: &DepthUpdateEvent) {
    let next_expected = book.last_update_id + 1;

    // Ignore outdated updates.
    if update.final_update_id < next_expected {
        warn!(
            expected = next_expected,
            final_update_id = update.final_update_id,
            "outdated depth update"
        );
        return;
    }

    // Detect gaps in the update sequence.
    if update.first_update_id > next_expected {
        warn!(
            expected = next_expected,
            first_update_id = update.first_update_id,
            final_update_id = update.final_update_id,
            "non-contiguous depth update"
        );
        return;
    }

    for [price, qty] in &update.bids {
        if qty == "0" {
            book.bids.remove(price);
        } else {
            book.bids.insert(price.clone(), qty.clone());
        }
    }

    for [price, qty] in &update.asks {
        if qty == "0" {
            book.asks.remove(price);
        } else {
            book.asks.insert(price.clone(), qty.clone());
        }
    }

    book.last_update_id = update.final_update_id;
}
