pub mod config;
pub mod events;
pub mod metrics;
pub mod rate_limit;
pub mod tls;

use once_cell::sync::Lazy;
use serde::Deserialize;
use simd_json::serde::from_slice;
use std::{
    collections::{HashMap, HashSet},
    env, fs,
    time::Duration,
};
use tracing::warn;

use crate::events::{Event, StreamMessage};

/// Configuration for global streams and per-symbol stream suffixes.
#[derive(Clone, Deserialize)]
pub struct StreamConfig {
    pub global: Vec<String>,
    #[serde(rename = "per_symbol")]
    pub per_symbol: Vec<String>,
}

/// Loads the stream configuration from a JSON file specified by the
/// `STREAMS_CONFIG` environment variable. If the variable is unset or the file
/// fails to load, a built-in default configuration is used.
static STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    if let Ok(path) = env::var("STREAMS_CONFIG") {
        if let Ok(mut content) = fs::read(path) {
            if let Ok(cfg) = from_slice(&mut content) {
                return cfg;
            }
        }
    }
    let mut data = include_bytes!("../../streams.json").to_vec();
    from_slice(&mut data).expect("invalid default stream configuration")
});

// Exchange specific configurations
static SPOT_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    let mut data = include_bytes!("../../streams_spot.json").to_vec();
    from_slice(&mut data).expect("invalid spot stream configuration")
});

static FUTURES_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    let mut data = include_bytes!("../../streams_futures.json").to_vec();
    from_slice(&mut data).expect("invalid futures stream configuration")
});

static OPTIONS_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    let mut data = include_bytes!("../../streams_options.json").to_vec();
    from_slice(&mut data).expect("invalid options stream configuration")
});

static GATEIO_SPOT_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    let mut data = include_bytes!("../../streams_gateio_spot.json").to_vec();
    from_slice(&mut data).expect("invalid gateio spot stream configuration")
});

static GATEIO_FUTURES_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    let mut data = include_bytes!("../../streams_gateio_futures.json").to_vec();
    from_slice(&mut data).expect("invalid gateio futures stream configuration")
});


static LATOKEN_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    let mut data = include_bytes!("../../streams_latoken.json").to_vec();
    from_slice(&mut data).expect("invalid latoken stream configuration")
static BITGET_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    let mut data = include_bytes!("../../streams_bitget.json").to_vec();
    from_slice(&mut data).expect("invalid bitget stream configuration")
});

static COINEX_SPOT_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    let mut data = include_bytes!("../../streams_coinex_spot.json").to_vec();
    from_slice(&mut data).expect("invalid coinex spot stream configuration")
});

static COINEX_PERPETUAL_STREAM_CONFIG: Lazy<StreamConfig> = Lazy::new(|| {
    let mut data = include_bytes!("../../streams_coinex_perpetual.json").to_vec();
    from_slice(&mut data).expect("invalid coinex perpetual stream configuration")
});

/// Returns the default stream configuration.
pub fn default_stream_config() -> &'static StreamConfig {
    &STREAM_CONFIG
}

/// Returns the stream configuration for the given exchange name.
pub fn stream_config_for_exchange(name: &str) -> &'static StreamConfig {
    match name {
        "Binance.US Spot" | "Binance Global Spot" => &SPOT_STREAM_CONFIG,
        "Binance Futures" | "Binance Delivery" => &FUTURES_STREAM_CONFIG,
        "Binance Options" => &OPTIONS_STREAM_CONFIG,
        "Gate.io Spot" => &GATEIO_SPOT_STREAM_CONFIG,
        "Gate.io Futures" => &GATEIO_FUTURES_STREAM_CONFIG,
        "Gate.io Spot" => &GATEIO_STREAM_CONFIG,
        "CoinEx Spot" => &COINEX_SPOT_STREAM_CONFIG,
        "CoinEx Perpetual" => &COINEX_PERPETUAL_STREAM_CONFIG,
        "LATOKEN" => &LATOKEN_STREAM_CONFIG,
        "Bitget" => &BITGET_STREAM_CONFIG,
        _ => default_stream_config(),
    }
}

/// Builds a list of Binance WebSocket stream names split into chunks using the
/// global stream configuration.
///
/// Global streams are combined with per-symbol streams generated by pairing
/// each symbol with a set of suffixes. Symbols are lowercased before being
/// combined. The complete list is then divided into chunks containing at most
/// `chunk_size` stream names.
pub fn chunk_streams(symbols: &[&str], chunk_size: usize) -> Vec<Vec<String>> {
    chunk_streams_with_config(symbols, chunk_size, default_stream_config())
}

/// Builds stream name chunks using a provided configuration.
pub fn chunk_streams_with_config(
    symbols: &[&str],
    chunk_size: usize,
    config: &StreamConfig,
) -> Vec<Vec<String>> {
    if chunk_size == 0 {
        return Vec::new();
    }

    let mut stream_set: HashSet<String> =
        HashSet::with_capacity(config.global.len() + symbols.len() * config.per_symbol.len());
    stream_set.extend(config.global.iter().cloned());

    for &sym in symbols {
        let sym_lower = sym.to_lowercase();
        for suffix in &config.per_symbol {
            stream_set.insert(format!("{}@{}", sym_lower, suffix));
        }
    }

    let mut streams: Vec<String> = stream_set.into_iter().collect();
    streams.sort();
    let capacity = streams.len().div_ceil(chunk_size);
    let mut result = Vec::with_capacity(capacity);
    for chunk in streams.chunks(chunk_size) {
        result.push(chunk.to_vec());
    }
    result
}

/// Calculates the next backoff duration for reconnection attempts.
///
/// If a run completed successfully and lasted at least `min_stable`, the
/// backoff is reset to one second. Otherwise it doubles, bounded by
/// `max_backoff`.
pub fn next_backoff(
    previous: Duration,
    run_duration: Duration,
    was_successful: bool,
    max_backoff: Duration,
    min_stable: Duration,
) -> Duration {
    if was_successful && run_duration >= min_stable {
        Duration::from_secs(1)
    } else {
        std::cmp::min(previous * 2, max_backoff)
    }
}

/// Logs a warning for unknown events. The raw payload is included for easier troubleshooting.
pub fn handle_stream_event(event: &StreamMessage<'_>, raw: &str) {
    if matches!(event.data, Event::Unknown) {
        warn!(
            event = "unknown",
            stream = %event.stream,
            payload = %raw,
            "unknown event",
        );
        if crate::config::metrics_enabled() {
            ::metrics::counter!("unknown_events").increment(1);
        }
    }
}

// Order book handling -------------------------------------------------------

use events::DepthUpdateEvent;

/// Snapshot of the order book returned by the REST `depth` endpoint.
#[derive(Debug, Deserialize)]
pub struct DepthSnapshot {
    #[serde(rename = "lastUpdateId")]
    pub last_update_id: u64,
    pub bids: Vec<[String; 2]>,
    pub asks: Vec<[String; 2]>,
}

/// In-memory representation of an order book for a single symbol.
#[derive(Debug, Clone, Default)]
pub struct OrderBook {
    pub bids: HashMap<String, String>,
    pub asks: HashMap<String, String>,
    pub last_update_id: u64,
}

impl From<DepthSnapshot> for OrderBook {
    fn from(snapshot: DepthSnapshot) -> Self {
        Self {
            bids: snapshot.bids.into_iter().map(|[p, q]| (p, q)).collect(),
            asks: snapshot.asks.into_iter().map(|[p, q]| (p, q)).collect(),
            last_update_id: snapshot.last_update_id,
        }
    }
}

/// Result of attempting to apply a depth update to an order book.
#[derive(Debug, PartialEq, Eq)]
pub enum ApplyResult {
    Applied,
    Outdated,
    Gap,
}

/// Applies a websocket depth update diff to an existing order book snapshot.
pub fn apply_depth_update(book: &mut OrderBook, update: &DepthUpdateEvent<'_>) -> ApplyResult {
    let next_expected = book.last_update_id + 1;

    // Ignore outdated updates.
    if update.final_update_id < next_expected {
        warn!(
            expected = next_expected,
            final_update_id = update.final_update_id,
            "outdated depth update"
        );
        return ApplyResult::Outdated;
    }

    // Detect gaps in the update sequence.
    if update.first_update_id > next_expected
        || update.previous_final_update_id != book.last_update_id
    {
        warn!(
            expected = next_expected,
            first_update_id = update.first_update_id,
            previous_final_update_id = update.previous_final_update_id,
            final_update_id = update.final_update_id,
            "non-contiguous depth update"
        );
        if crate::config::metrics_enabled() {
            ::metrics::counter!("md_ws_gap_total").increment(1);
        }
        return ApplyResult::Gap;
    }

    for [price, qty] in &update.bids {
        if qty.as_ref() == "0" {
            book.bids.remove(price.as_ref());
        } else {
            book.bids.insert(price.to_string(), qty.to_string());
        }
    }

    for [price, qty] in &update.asks {
        if qty.as_ref() == "0" {
            book.asks.remove(price.as_ref());
        } else {
            book.asks.insert(price.to_string(), qty.to_string());
        }
    }

    book.last_update_id = update.final_update_id;
    ApplyResult::Applied
}

/// Fast-forwards an order book by applying a sequence of buffered depth updates.
pub fn fast_forward(book: &mut OrderBook, updates: &[DepthUpdateEvent<'_>]) {
    for update in updates {
        apply_depth_update(book, update);
    }
}
